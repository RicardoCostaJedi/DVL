<!DOCTYPE html>
<html>
  <head>
    <title>DVL Simple Heatmap + Cluster</title>
    <link type="text/css"         href="../../css/smoothness/jquery-ui-1.8.7.custom.css" rel="Stylesheet" />	
    <script type="text/javascript" src="../../js/jquery-1.4.4.min.js"></script>
    <script type="text/javascript" src="../../js/jquery-ui-1.8.7.custom.js"></script>
    <script type="text/javascript" src="../../d3.js"></script>
    <script type="text/javascript" src="../../protovis-r3.2.js"></script>
    <script type="text/javascript" src="../../sprintf.js"></script>
    <script type="text/javascript" src="../../dvl.js"></script>
    <style type="text/css">

body {
  font: 12px sans-serif;
}

.background {
  fill: #ccc;
}

.lines {
  shape-rendering: crispEdges;
}

.bars {
  shape-rendering: crispEdges;
}

    </style>

  </head>
  <body>
    <div>
      <button id="sel" onclick="remove()">Remove ??</button>
      <button onclick="changeValues()">Change Values</button>
      <button onclick="reclusterY()">Re-cluster on Y</button>
    </div>
  </body>
  <script type="text/javascript">
  
  var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
  var n = letters.length;
  var data = [];
  for (var x=0; x < 15; x++) {
    for (var y=0; y < 15; y++) {
      var skip = (Math.random() < 0.2);
      if (!skip) {
        data.push({
          x: 'x' + letters[x] + letters[x * 13 % n] + letters[x *  7 % n] + (100 + x),
          y: 'y' + letters[y] + letters[y * 11 % n] + letters[y * 23 % n] + (100 + y),
          value1: Math.random(),
          value2: Math.random()
        });
      }
    }
  }
  data = dvl.def(data, 'data');
  
	var getX = dvl.acc('x');
	var getY = dvl.acc('y');
	var valueSource = dvl.def('value1', 'measure')
	var getV = dvl.acc(valueSource);
	
	var size = dvl.def({ width: 600, height: 600 }, "size");
	var margin = dvl.def({ top: 30, bottom: 70, left: 70, right: 30 }, "margin");
	
	var clusterY = dvl.def(1, "clusterY");
	
	var dataY = dvl.apply({
	  fn: function(data, acc, cx) {
	    var mapped = dvl.util.uniq(data.map(acc));
  	  mapped.sort(function(a, b) { return a.substr(cx) > b.substr(cx) ? 1 : -1; });
  	  return mapped;
  	},
	  args: [data, getY, clusterY]
  });
  
  var panel = dvl.svg.canvas({
    selector:'body',
    size:size,
    margin:margin
  });
	
  var sx = dvl.scale.ordinal({
    name: "scale_x",
    domain: { data:data, acc:getX, sort:true, uniq:true },
    rangeFrom: 0,
    rangeTo: panel.width,
    padding: 10
  })
  
  var sy = dvl.scale.ordinal({
    name: "scale_y",
    //domain: { data:data, acc:getY, sort:true, uniq:true },
    domain: { data:dataY },
    rangeFrom: 0,
    rangeTo: panel.height,
    padding: 10
  });
  
  var sc = dvl.scale.linear({
    name: "scale_color",
    domain: { data: dvl.def([0, 1]) },
    rangeFrom: "#f00",
    rangeTo: "#0f0"
  });
  
  var scaledTicksX = dvl.gen.fromArray(sx.ticks, null, sx.scale),
      scaledTicksY = dvl.gen.fromArray(sy.ticks, null, sy.scale);
  
  dvl.svg.lines({
    panel: panel,
    duration: 400,
    props: {
      key: sx.ticks,
      left: scaledTicksX,
      top1: 0,
      bottom2: 0,
      stroke: "black"
    }
  });
  
  dvl.svg.lines({
    panel: panel,
    duration: 400,
    props: {
      key: sy.ticks,
      top: scaledTicksY,
      left1: 0,
      right2: 0,
      stroke: "black"
    }
  });
  
  dvl.svg.labels({
    panel: panel,
    duration: 400,
    props: {
      key: sx.ticks,
      left: scaledTicksX,
      bottom: -3,
      text: sx.ticks,
      baseline: "top",
      align: "start",
      angle: 45
    }
  });
  
  dvl.svg.labels({
    panel: panel,
    duration: 400,
    props: {
      key: sy.ticks,
      left: -3,
      top:  scaledTicksY,
      text: sy.ticks,
      align: "end",
      baseline: "middle"
    }
  });
  
  var sizeX = dvl.apply({
    fn: function(b) { return 0.9 * b; },
    args: sx.band
  });
  var sizeY = dvl.apply({
    fn: function(b) { return 0.9 * b; },
    args: sy.band
  });
  
  dvl.svg.bars({
    panel: panel,
    duration: 400,
    props: {
      key: dvl.gen.fromArray(data, function(d) { return d.x + '_' + d.y; }),
      centerX: dvl.gen.fromArray(data, getX, sx.scale),
      centerY: dvl.gen.fromArray(data, getY, sy.scale),
      width: sizeX,
      height: sizeY,
      fill: dvl.gen.fromArray(data, getV, sc.scale),
    }
  });
  
  /////////////////

  var selectedCord, selected;
  function select() {
    selectedCord = Math.random() > 0.5 ? 'x' : 'y';
    if (data.get().length > 0) {
      selected = data.get()[Math.floor(Math.random() * data.get().length)][selectedCord];
      d3.select("#sel").text("Remove " + selected);
    } else {
      d3.select("#sel").text("Empty");
    }
  }
  select();
  function remove() {
    var d = data.get();
    d = d.filter(function(d) { return d[selectedCord] != selected; });
    data.set(d).notify();
    select();
  }
  
  function reclusterY() {
    clusterY.set(clusterY.get() % 3 + 1).notify();
  }
  
  function changeValues() {
    var d = valueSource.get()
    if(d == 'value1') {
      d = 'value2';
    } else {
      d = 'value1';
    }
    valueSource.set(d).notify();
  }
  
  </script>
</html>
